package com.charlag.tuta.entities

import kotlinx.serialization.*
import kotlinx.serialization.builtins.ListSerializer
import kotlinx.serialization.builtins.serializer
import kotlinx.serialization.descriptors.*
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder
import kotlin.reflect.KClass

/**
 * Type of the entity.
 * Entities and services are grouped into "apps" (like "sys" or "tutanota") which are namespaces
 * with their own versioning and migrations.
 */
enum class MetamodelType {
    /**
     * Instance (separate database entity) which does not belong to any particular list. Has a
     * single ID - [GeneratedId] or [CustomId].
     */
    ELEMENT_TYPE,
    /**
     * Instance (separate database entity) which belongs to one of the lists. It means that it's
     * Id is [IdTuple], it can be loaded in ranges.
     */
    LIST_ELEMENT_TYPE,
    /**
     * Not a separate database entity but a structure on Instance or DataTransferType. Has it's
     * own id.
     */
    AGGREGATED_TYPE,
    /**
     * Entity which is not represented in the database but is used for sending/receiving data via
     * services.
     */
    DATA_TRANSFER_TYPE;
}

enum class ValueType {
    BooleanType,
    NumberType,
    StringType,
    DateType,
    GeneratedIdType,
    CustomIdType,
    BytesType,
    CompressedStringType;
}

enum class AssociationType {
    /**
     * Id referencing ElementEntity
     */
    ELEMENT_ASSOCIATION,
    /**
     * IdTuple referencing ListElementEntity
     */
    LIST_ELEMENT_ASSOCIATION,
    /**
     * Id referencing the whole list (listId from [IdTuple])
     */
    LIST_ASSOCIATION,
    /**
     * Aggregation.
     * See [MetamodelType.AGGREGATED_TYPE].
     */
    AGGREGATION;
}

enum class Cardinality {
    /**
     * Single value. Must be present.
     */
    One,
    /**
     * Single value. May be absent.
     */
    ZeroOrOne,
    /**
     * List of values. May be empty.
     */
    Any;
}

/**
 * Value descriptor in TypeModel.
 */
data class Value(
    val type: ValueType,
    val cardinality: Cardinality,
    val encrypted: Boolean,
    val final: Boolean
)

/**
 * Association description in TypeModel.
 */
data class Association(
    val type: AssociationType,
    val cardinality: Cardinality,
    val refType: String,
    val final: Boolean,
    /**
     * If it belongs to another app
     */
    val external: Boolean
)

/**
 * Description of the entity structure and type.
 */
data class TypeModel(
    val name: String,
    val encrypted: Boolean,
    val type: MetamodelType,
    val id: Long,
    val rootId: String,
    val values: Map<String, Value> = mapOf(),
    val associations: Map<String, Association> = mapOf(),
    val version: Int
)

/**
 * Wrapper around TypeModel to look up serialization features by name.
 */
data class TypeInfo<T : Any>(
    val klass: KClass<T>,
    val model: String,
    val typemodel: TypeModel,
    val serializer: KSerializer<T>
)

object IdSerilizer : KSerializer<Id> {
    override val descriptor = buildClassSerialDescriptor("IdSerializier")

    override fun serialize(encoder: Encoder, value: Id) {
        encoder.encodeString(value.asString())
    }

    override fun deserialize(decoder: Decoder): Id {
        return GeneratedId(decoder.decodeString())
    }
}

@Serializable(with = IdSerilizer::class)
abstract class Id {
    abstract fun asString(): String
}

operator fun Id.compareTo(id: Id): Int = asString().compareTo(id.asString())

/**
 * Unique ID which must be generated by the server.
 * Contains timestamp, counter for timestamp collisions and server id.
 */
@Serializable(with = IdSerilizer::class)
data class GeneratedId(val stringData: String) : Id() {
    override fun asString(): String = stringData
}

/**
 * Non-unique Id which is created from the string.
 */
@Serializable(with = CustomId.IdSerilizer::class)
data class CustomId(val stringData: String) : Id() {
    // TODO
    override fun asString(): String = stringData

    @Serializer(forClass = Id::class)
    companion object IdSerilizer : KSerializer<Id> {
        override fun serialize(encoder: Encoder, value: Id) {
            encoder.encodeString(value.asString())
        }

        override fun deserialize(decoder: Decoder): Id {
            return CustomId(decoder.decodeString())
        }
    }
}

@Serializable
@OptIn(ExperimentalSerializationApi::class)
data class IdTuple(val listId: Id, val elementId: Id) {
    @Serializer(forClass = IdTuple::class)
    companion object :
        KSerializer<IdTuple> {
        override val descriptor: SerialDescriptor = buildClassSerialDescriptor("IdTuple")

        override fun serialize(encoder: Encoder, value: IdTuple) {
            val listDecoder = encoder.beginCollection(
                ListSerializer(String.serializer()).descriptor,
                2
            )
            listDecoder.encodeStringElement(descriptor, 0, value.listId.asString())
            listDecoder.encodeStringElement(descriptor, 1, value.elementId.asString())
            listDecoder.endStructure(descriptor)
        }

        override fun deserialize(decoder: Decoder): IdTuple {
            val listDecoder =
                decoder.beginStructure(
                    ListSerializer(String.serializer()).descriptor
                )
            val idTuple = IdTuple(
                GeneratedId(
                    listDecoder.decodeStringElement(
                        descriptor,
                        0
                    )
                ),
                GeneratedId(
                    listDecoder.decodeStringElement(
                        descriptor,
                        1
                    )
                )
            )
            listDecoder.endStructure(descriptor)
            return idTuple
        }

        fun fromRawValues(listId: String, elementId: String): IdTuple {
            return IdTuple(
                GeneratedId(
                    listId
                ), GeneratedId(elementId)
            )
        }
    }
}